// MIT License
//
// Copyright(c) 2017 ForensicTools
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files(the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions :
//
// The above copyright notice and this permission notice shall be included in 
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING 
// FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
// IN THE SOFTWARE.
//

// Authors:	Joseph Bartelmo   <joebartelmo@gmail.com>
//			Robert Suter      <rxs2165@g.rit.edu>
//			Andrew Botsehagow <abotschagow@gmail.com>
#include "stdafx.h"
#include "AES.h"
#include "encrypt.h"
#include <string>
#include <fstream>
#include <chrono>

#define AES_KEY_SIZE 128

long long seconds_since_epoch() {
	// get the current time
	const auto now = std::chrono::system_clock::now();

	// transform the time into a duration since the epoch
	const auto epoch = now.time_since_epoch();

	// cast the duration into seconds
	const auto seconds = std::chrono::duration_cast<std::chrono::seconds>(epoch);

	// return the number of seconds
	return seconds.count();
}

uint8_t* to_byte_array(long long i) {
	std::cout << i;
	uint8_t toReturn[8] = {
		(i & 0x00000000000000ff),
		(i & 0x000000000000ff00) >> 8,
		(i & 0x0000000000ff0000) >> 16,
		(i & 0x00000000ff000000) >> 24,
		(i & 0x000000ff00000000) >> 32,
		(i & 0x0000ff0000000000) >> 40,
		(i & 0x00ff000000000000) >> 48,
		(i & 0xff00000000000000) >> 56
	};
	return toReturn;
}

namespace ARM {
	/// <summary>
	/// Encrypts the given file with AES128 and spits out the key to the commandline.
	/// </summary>
	/// <return> Success </return>
	bool encrypt_file(std::string filename) {
		std::cout << "IV: ";
		uint8_t *iv = to_byte_array(seconds_since_epoch());
		std::cout << "\nKEY: ";
		uint8_t *key = to_byte_array(seconds_since_epoch());
		std::cout << std::endl;

		try {
			AES aes = AES();
			std::ifstream input(filename, std::ifstream::ate | std::ifstream::binary);
			int length = input.tellg();
			uint8_t* data = new uint8_t[length];
			input.seekg(0, std::ios::beg);
			input.read((char*)data, length);
			input.close();

			aes.encrypt(64, length, iv, data, key);
			
			std::ofstream output(filename + "aes_enc");

			output.write((char*)data, length);

			delete data;
		}
		catch (std::exception&) {
			return false;
		}
		return true;
	}
}